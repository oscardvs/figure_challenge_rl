# Challenge configuration
#
# The challenge is a sequential 30-step gauntlet at a single Netlify SPA.
# Home page → click START → /step1?version=3 → /step2?version=3 → ... → /step30?version=3
# Each step presents a unique puzzle. Solving the puzzle reveals a 6-character
# code that must be entered in a textbox and submitted to advance.

base_url: "https://serene-frangipane-7fd25b.netlify.app"
num_steps: 30
version: 1

# URL patterns
home_url: "https://serene-frangipane-7fd25b.netlify.app/"
step_url_template: "https://serene-frangipane-7fd25b.netlify.app/step{step}?version={version}"

# Per-step settings
defaults:
  max_actions_per_step: 30   # max agent actions before giving up on a step
  max_actions_total: 500     # max total actions across all 30 steps
  wait_after_action_ms: 500  # wait time for page to settle after action
  timeout_seconds: 300       # 5-minute total time budget
  viewport:
    width: 1280
    height: 720
  headless: false

# MCTS data collection
mcts:
  iterations_per_step: 15
  candidates_per_node: 5   # K actions sampled at each node
  exploration_constant: 1.4 # UCB1 c parameter
  q_blend_alpha: 0.7       # weight for MCTS Q vs critic Q
  min_q_diff_for_dpo: 0.2  # minimum Q-value gap for preference pairs

# Reward configuration
reward:
  step_complete: 1.0        # reward for advancing to next step
  all_complete: 10.0        # bonus for completing all 30 steps
  failure: 0.0

# Parallel execution (submission time) — not applicable for sequential gauntlet
# but kept for potential future use with independent step training
parallel:
  num_workers: 1
  total_time_budget_seconds: 300

# Known challenge types (randomized per run — any type can appear at any step)
challenge_types:
  - dom_extraction       # Code visible in DOM text or hidden elements
  - math_puzzle          # Arithmetic expression to solve, enter result
  - keyboard_sequence    # Press specific key sequence
  - radio_brute_force    # Try radio button combinations + submit
  - scroll_to_find       # Scroll through long page, avoid trap buttons
  - hover_reveal         # Hover over elements to reveal hidden code
  - timing_capture       # Capture code during timed reveal
  - multi_tab            # Visit multiple tabs to collect code fragments
  - sequence_challenge   # Click/hover/type in specific sequence
  - video_frames         # Navigate video frames to find code
  - split_parts          # Collect code parts scattered across page
  - rotating_code        # Capture code that rotates/changes rapidly
  - delayed_reveal       # Wait for delayed code reveal
  - drag_and_drop        # Drag elements to correct positions
  - animated_button      # Click moving/animated button to submit
  - shadow_dom           # Traverse nested shadow DOM layers
  - canvas_draw          # Draw on canvas to reveal code
  - audio_challenge      # Play audio and extract code
  - websocket            # Connect to WebSocket server for code
  - service_worker       # Register service worker to cache code
  - iframe_recursive     # Navigate nested iframes to extract code
  - mutation_observer    # Trigger and observe DOM mutations for code
